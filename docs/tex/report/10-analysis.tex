\chapter{Аналитический раздел}

\section{Постановка задачи}

В соответствии с заданием на курсовую работу необходимо разработать загружаемый модуля ядра ОС Linux для отключения сетевого оборудования системы при подключении USB–устройства. Для решения данной задачи необходимо:

\begin{itemize}
	\item[---] проанализировать методы обработки событий, возникающих при взаимодействии с USB–устройствами;
	\item[---] проанализировать структуры и функции ядра, предоставляющие информацию о USB–устройствах;
	\item[---] разработать алгоритмы и структуру программного обеспечения;
	\item[---] реализовать программное обеспечение;
	\item[---] исследовать разработанное программное обеспечение.
\end{itemize}

\section{Обработка событий от USB-устройств}

Для обработки событий, возникающих при работе с USB–устройствами, например, таких как подключение или отключение устройства, необходимо узнать о возникновении события и выполнить необходимую обработку после возникновения события.

Далее будут рассмотрены существующие подходы к определению возникновения событий от USB–устройств и выбран наиболее подходящий для реализации в данной работе

\subsection{usbmon}

\texttt{usbmon}~\cite{usbmon} --- это средство ядра Linux, которое используется для сбора информации о событиях, произошедших на устройствах ввода--вывода, подключенных посредством USB.

\texttt{usbmon} предоставляет информацию о запросах, сделанных драйверами устройств к драйверам хост--контроллера (HCD). В случае, когда драйвера хост--контроллера неисправны, данные, предоставленные \texttt{usbmon}, могут не соответствовать действительным переданным данным.

В настоящее время реализованы два программных интерфейса для взаимодействия с \texttt{usbmon}: 
\begin{itemize}
    \item[---] текстовый --- данный интерфейс устарел, но сохраняется для совместимости;
    \item[---] бинарный --- доступен через символьное устройство в пространстве имен \texttt{/dev}.
\end{itemize}

К особенностям \texttt{usbmon} относятся:

\begin{itemize}
	\item[---] возможность просматривать собранную информацию через специальное ПО (например, \texttt{Wireshark}~\cite{wireshark});
	\item[---] возможность отслеживать события на одном порте USB или на всех сразу;
	\item[---] отсутствие возможности вызова обработчика при возникновении определенного события.
\end{itemize}

При этом, \texttt{usbmon} позволяет отслеживать события, но не позволяет реагировать на них без программной доработки для реализации обработчика.

В листингах \ref{lst:usbmon-packet} и  представлена структура ответа, полученного после события, случившегося на USB--устройстве (например, подключение к компьютеру).

\listingfile{usbmon_packet.h}{usbmon-packet}{C}{Структура usbmon\_packet. Часть 1}{linerange={1-9}}

\listingfile{usbmon_packet.h}{usbmon-packet-2}{C}{Структура usbmon\_packet. Часть 2}{linerange={10-27}}

\subsection{udevadm}

\texttt{udevadm} \cite{udevadm} --- инструмент для управления устройствами \texttt{udev}. Структура \texttt{udev} описана в библиотеке \texttt{libudev} \cite{libudev}, которая не является системной библиотекой Linux. В данной библиотеке представлен программный интерфейс для мониторинга и взаимодействия с локальными устройствами.

При помощи \texttt{udevadm} можно получить полную информацию об устройстве, полученную из его представления в \texttt{sysfs}, чтобы создать корректные правила и обработчики событий для устройства. Кроме того можно получить список событий для устройства, установить наблюдение за ним.

Особенности \texttt{udevadm}:

\begin{itemize}
	\item[---] возможность привязки своего обработчика к событию;
	\item[---] невозможность использования интерфейса в ядре Linux;
\end{itemize}


В листинге \ref{lst:udevadm} представлен пример правила обработки событий, задаваемого с помощью \texttt{udevadm}.

\listingfile{udevadm.sh}{udevadm}{Bash}{Правила \texttt{udevadm}}{}

\subsection{Уведомители}

Ядро Linux содержит механизм, называемый <<уведомителями>> (\texttt{notifiers}) или <<цепочками уведомлений>> (\texttt{notifiers chains}), который позволяет различным подсистемам подписываться на асинхронные события от других подсистем. 

В настоящее время цепочки уведомлений активно используется в ядре; существуют цепочки для событий \texttt{hotplug} памяти, изменения политики частоты процессора, события \texttt{USB hotplug}, загрузки и выгрузки модулей, перезагрузки системы, изменения сетевых устройств \cite{notifications}.

В листинге \ref{lst:notifier-block} представлена структура \texttt{notifier\_block} \cite{notifierblock}.

\listingfile{notifiers.h}{notifier-block}{C}{Структура \texttt{notifier\_block}}{linerange={1-5}}

Данная структура описана в \texttt{/include/linux/notifier.h}. Она содержит указатель на функцию--обработчик уведомления (\texttt{notifier\_call}), указатель на следующий уведомитель (\texttt{next}) и приоритет уведомителя (\texttt{priority}). Уведомители с более высоким значением приоритета выполняются первее.

В листинге \ref{lst:notifier-fn-t} представлена сигнатура функии \texttt{notifier\_call}.

\listingfile{notifiers.h}{notifier-fn-t}{C}{Структура \texttt{notifier\_fn\_t}}{linerange={7}}

Сигнатура содержит указатель на уведомитель (\texttt{nb}), действие, при котором срабатывает функция (\texttt{action}) и данные, которые передаются от действия в обработчик (\texttt{data}).

Для регистрации уведомителя для USB--портов используются функции регистрации и удаления уведомителя, представленные в листинге \ref{lst:usb-notifiers}.

\listingfile{notifiers.h}{usb-notifiers}{C}{Уведомители на USB--портах}{linerange={10-16}}

Прототипы и константы для действий описаны в файле \texttt{/include/linux/notifier.h}, а реализации функций --- в файле\\ \texttt{/drivers/usb/core/notify.c}. Действие \texttt{USB\_DEVICE\_ADD} означает подключение нового устройства, а \texttt{USB\_DEVICE\_REMOVE} --- удаление, соответственно.

Особенности \texttt{уведомителей}:

\begin{itemize}
	\item[---] возможность привязки своего обработчика к событию;
	\item[---] возможность добавления более чем одного обработчика событий;
	\item[---] возможность использования интерфейса в загружаемом модуле ядра;
\end{itemize}

\section{USB-устройства в ядре Linux}

\subsection{Структура usb\_device}

Для хранения информации о USB--устройстве в ядре используется структура \texttt{usb\_device}, описанная в \texttt{/inlclude/linux/usb.h}~\cite{usb_device}. Данная структура представлена в листинге~\ref{lst:usb-device}.

\listingfile{usb_device.h}{usb-device}{C}{Структура usb\_device}{}

Каждое USB--устройство должно соответствовать спецификации USB--IF~\cite{usbspec}, одним из требований которой является наличие идентификатора поставщика (\texttt{Vendor ID (VID)}) и идентификатора продукта (\texttt{Product ID (PID)}). 

Эти данные присутствуют в поле \texttt{descriptor} структуры \texttt{usb\_device}. Структура дескриптора \texttt{usb\_device\_descriptor}, описанная в \texttt{/include/uapi/linux/usb/ch9.h}, представлена в листинге~\ref{lst:usb-device-descriptor}.

\listingfile{usb_device_descriptor.h}{usb-device-descriptor}{C}{Структура usb\_device\_descriptor}{}

\subsection{Структура usb\_device\_id}

При подключении USB--устройства к компьютеру, оно идентифицируется и идентификационная информация записывается в структуру \texttt{usb\_device\_id}~\cite{usb_device_id}. Данная структура представлена в листинге \ref{lst:usb-device-id}.

%\listingfile{usb_device_id.h}{usb-device-id}{C}{Структура usb\_device\_id}{}

\section{Особенности разработки загружаемых модулей ядра Linux}

\subsection{Пользовательское пространство памяти и пространство памяти ядра}

Пользовательские программы работают в пользовательском пространстве, а ядро и его модули --- в пространстве ядра.

Операционная система должна обеспечивать программы доступом к аппаратной части компьютера, независимую работу программ и защиту от несанкционированного доступа к ресурсам. Решение этих задач становится возможным в случае, если процессор обеспечивает защиту системного программного обеспечения от прикладных программ.

Ядро Linux выполняется на самом высоком уровне, где разрешено выполнение любых инструкций и доступ к произвольным участкам памяти, а приложения выполняются на самом низком уровне, в котором процессор регулирует прямой доступ к аппаратной части и несанкционированный доступ к памяти. Ядро выполняет переход из пользовательского пространства в пространство ядра, когда приложение делает системный вызов или приостанавливается аппаратным прерыванием. Код ядра, выполняя системный вызов, работает в контексте процесса --- он действует от имени вызывающего процесса и в состоянии получить данные в адресном пространстве процесса. Код, который обрабатывает прерывания, является асинхронным по отношению к процессам и не связан с каким--либо определенным процессом.

Ролью модуля ядра является расширение функциональности ядра без его перекомпиляции. Код модулей выполняется в пространстве ядра.

\subsection{Запуск программ пользовательского пространства в пространстве ядра}

Для запуска программ пространства пользователя из пространства ядра используется \texttt{usermode-helper API}. Чтобы создать процесс из пространства пользователя необходимо указать имя исполняемого файла, аргументы, с которыми требуется запустить программу, и переменные окружения \cite{umhelper}.

В листинге \ref{lst:umh} представлена структура процесса, использующегося в \texttt{usermode-helper API} и сигнатура функции вызова~\cite{umh}.

\listingfile{umod_helper.h}{umh}{C}{\texttt{usermode-helper API}}{}
    
\section*{Выводы}

Были рассмотрены методы обработки событий, возникающих при взаимодействии с USB--устройствами. Среди рассмотренных методов был выбран механизм уведомителей, так как он позволяет привязать свой обработчик события, а также реализован на уровне ядра Linux. Были рассмотрены структуры и функции ядра для работы с уведомителями, а также особенности разработки загружаемых модулей ядра.
